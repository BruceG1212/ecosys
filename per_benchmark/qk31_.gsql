use graph ldbc_snb

drop query qk31_
CREATE QUERY qk31_ () SYNTAX v1 {
/* __TF_HOP_BEGIN:0 */

// for src id propagation
SetAccum<VERTEX> @srcIdOnlyPropagAcc_1;

// for VSet global accums
SetAccum<VERTEX> @@GVS;

// for active marking accums
OrAccum @activeNext, @activeNextCopy;

// while loop iteration counter
int i;

/* __TF_HOP_END:0 */
  SumAccum<int> @@comment_cnt;
  /* __TF_HOP_BEGIN:6 */
VS_s1 = { Person.* };


///////////////////////////
// LOWER BOUND LOOP [1..0]
///////////////////////////
TmpVS (ANY) = VS_s1;

///////////////////////////
// UPPER BOUND LOOP [1..3]
///////////////////////////

VS__1 = {};
i = 1;
WHILE TmpVS.size() > 0 AND i <= 3 DO
IF i == 1 THEN

// initialize srcIdOnlyPropagAcc_1

TmpVS =
        select t
        from   TmpVS:s -(KNOWS:x)-> _:t
        accum        t.@srcIdOnlyPropagAcc_1 += s;

ELSE

TmpVS =
        select t
        from   TmpVS:x_2 -(KNOWS:x)-> _:t
        accum  foreach s in x_2.@srcIdOnlyPropagAcc_1 do


                   // check that this is the shortest path to t
                   //(we didn't already reach it from s)
                   if not(t.@srcIdOnlyPropagAcc_1.contains(s)) then
                      t.@activeNext += true,
                      t.@srcIdOnlyPropagAcc_1 += s
                   end
                end
        post-accum t.@activeNextCopy = t.@activeNext,
                t.@activeNext = false
        having  t.@activeNextCopy;

END; // IF

VS__1 = VS__1 union TmpVS;
i = i + 1;
END; // WHILE
XXX1 =
        select  t
        from   VS__1:t
        accum  foreach s in t.@srcIdOnlyPropagAcc_1 do

                     @@comment_cnt += 1
                ,

                      @@GVS += s
                end
        post-accum t.@srcIdOnlyPropagAcc_1.clear();


V(Person) = {@@GVS};
@@GVS.clear();

/* __TF_HOP_END:9 */

  Print @@comment_cnt;

}

//install query q101
//run query q101()
