CREATE QUERY bi_10(STRING tagName, DATETIME minDate) FOR GRAPH ldbc_snb { 
  TYPEDEF tuple<INT person_id, INT score, INT friendsScore, INT total> tagScore;

  SetAccum<vertex<Person>> @@personAll;
  GroupByAccum<INT person_id, SumAccum<INT> score, SumAccum<INT> friendsScore> @@tagScoreMap;
  HeapAccum<tagScore>(100, total DESC, person_id ASC) @@tagScoreTop;

  vTag = { Tag.* };
  vTag = 
    SELECT v
    FROM vTag:v
    WHERE v.name == tagName;

  // find all persons that are interested in the tagName
  vPerson =
    SELECT t
    FROM vTag:s-(Person_HAS_INTEREST_Tag_REVERSE:e)->Person:t
    POST-ACCUM 
      @@tagScoreMap += (t.id -> 100, 0),
      @@personAll += t;

  // find all persons that have written a message having tagName after a given minDate
  vMessage = 
    SELECT t
    FROM vTag:s-((Comment_HAS_TAG_Tag_REVERSE|Post_HAS_TAG_Tag_REVERSE):e)->(Comment|Post):t
    WHERE t.creationDate > minDate;

  vPerson =
    SELECT t
    FROM vMessage:s-((Comment_HAS_CREATOR_Person|Post_HAS_CREATOR_Person):e)->Person:t
    POST-ACCUM 
      @@tagScoreMap += (t.id -> 1, 0),
      @@personAll += t;

  // calculate friends' score and push to heap
  vPerson = { @@personAll };
  vPerson = 
    SELECT s
    FROM vPerson:s-((Person_KNOWS_Person|Person_KNOWS_Person_REVERSE):e)->Person:t
    WHERE @@tagScoreMap.containsKey(t.id)
    ACCUM @@tagScoreMap += (s.id -> 0, @@tagScoreMap.get(t.id).score)
    POST-ACCUM @@tagScoreTop += tagScore(
        s.id, 
        @@tagScoreMap.get(s.id).score, 
        @@tagScoreMap.get(s.id).friendsScore, 
        (@@tagScoreMap.get(s.id).score + @@tagScoreMap.get(s.id).friendsScore));

  FOREACH ts IN @@tagScoreTop DO
    PRINT 
      ts.person_id AS person_id, 
      ts.score AS score, 
      ts.friendsScore AS friendsScore;
  END;
}