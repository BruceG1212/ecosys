USE GRAPH ldbc_snb
DROP QUERY bi_10

CREATE QUERY bi_10(string tgtTag, datetime date) FOR GRAPH ldbc_snb { 
  TYPEDEF tuple<int person_id, int score, int friendsScore, int total> tagScore;

  SetAccum<vertex<person>> @@personAll;
  GroupByAccum<int person_id, SumAccum<int> score, SumAccum<int> friendsScore> @@tagScoreMap;
  HeapAccum<tagScore>(100, total DESC, person_id ASC) @@tagScoreTop;

  vTag = { tag.* };
  vTag = 
    SELECT v
    FROM vTag:v
    WHERE v.name == tgtTag;

  // find all persons that are interested in the tgtTag
  vPerson =
    SELECT t
    FROM vTag:s-(person_hasInterest_tag_reverse:e)->person:t
    POST-ACCUM 
      @@tagScoreMap += (t.id -> 100, 0),
      @@personAll += t;

  // find all persons that have written a message having tgtTag after a given date
  vMessage = 
    SELECT t
    FROM vTag:s-((comments_hasTag_tag_reverse|post_hasTag_tag_reverse):e)->(comments|post):t
    WHERE t.creationDate > date;

  vPerson =
    SELECT t
    FROM vMessage:s-((comments_hasCreator_person|post_hasCreator_person):e)->person:t
    POST-ACCUM 
      @@tagScoreMap += (t.id -> 1, 0),
      @@personAll += t;

  // calculate friends' score and push to heap
  vPerson = { @@personAll };
  vPerson = 
    SELECT s
    FROM vPerson:s-((person_knows_person|person_knows_person_reverse):e)->person:t
    WHERE @@tagScoreMap.containsKey(t.id)
    ACCUM @@tagScoreMap += (s.id -> 0, @@tagScoreMap.get(t.id).score)
    POST-ACCUM @@tagScoreTop += tagScore(
        s.id, 
        @@tagScoreMap.get(s.id).score, 
        @@tagScoreMap.get(s.id).friendsScore, 
        (@@tagScoreMap.get(s.id).score + @@tagScoreMap.get(s.id).friendsScore));

  FOREACH ts IN @@tagScoreTop DO
    PRINT 
      ts.person_id AS person_id, 
      ts.score AS score, 
      ts.friendsScore AS friendsScore;
  END;	
}

INSTALL QUERY bi_10