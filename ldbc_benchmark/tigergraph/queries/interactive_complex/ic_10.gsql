USE GRAPH ldbc_snb
DROP QUERY ic_10

CREATE QUERY ic_10(VERTEX<person> personId, INT month, INT nextMonth) FOR GRAPH ldbc_snb {
  TYPEDEF TUPLE<INT personId, STRING personFirstName, STRING personLastName, INT commonInterestScore, STRING personGender, STRING personCityName> friendInfo;

  OrAccum @visited;
  SumAccum<STRING> @city;
  SetAccum<VERTEX<tag>> @@tagInterest;
  SumAccum<INT> @friendId, @common, @uncommon;
  MapAccum<INT, BOOL> @@postInterestMap;
  HeapAccum<friendInfo>(10, commonInterestScore DESC, personId ASC) @@friendInfoTop;

  vPerson = { personId };
  vFriend1h = 
    SELECT t
    FROM vPerson:s-((person_knows_person|person_knows_person_reverse):e)->person:t
    ACCUM 
      s.@visited += True,
      t.@visited += True;

  vFriend2h = 
    SELECT t
    FROM vFriend1h:s-((person_knows_person|person_knows_person_reverse):e)->person:t
    WHERE t.@visited == False
    AND ((month(t.birthday) == month AND day(t.birthday) >= 21) OR 
        (month(t.birthday) == nextMonth AND day(t.birthday) < 22));

  vFriend2h = 
    SELECT s
    FROM vFriend2h:s-(person_isLocatedIn_city:e)->city:t
    ACCUM s.@city = t.name;

  vTag = 
    SELECT t
    FROM vPerson:s-(person_hasInterest_tag:e)->tag:t
    POST-ACCUM @@tagInterest += t;

  vPost = 
    SELECT t
    FROM vFriend2h:s-(post_hasCreator_person_reverse:e)-post:t;

  vPost = 
    SELECT s
    FROM vPost:s-(post_hasTag_tag:e)->tag:t
    ACCUM 
      CASE 
        WHEN @@tagInterest.contains(t) THEN 
          @@postInterestMap += (s.id -> True)
        ELSE 
          @@postInterestMap += (s.id -> False)
      END;

  vFriend2h = 
    SELECT s
    FROM vFriend2h:s-(post_hasCreator_person_reverse:e)-post:t
    ACCUM 	
      CASE 
        WHEN @@postInterestMap.get(t.id) == True THEN 
          s.@common += 1
        ELSE 
          s.@uncommon += 1
      END
    POST-ACCUM @@friendInfoTop += 
        friendInfo(s.id, s.firstName, s.lastName, (s.@common-s.@uncommon), s.gender, s.@city);

  PRINT @@friendInfoTop;
}

INSTALL QUERY ic_10