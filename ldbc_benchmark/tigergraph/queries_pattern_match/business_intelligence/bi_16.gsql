use graph ldbc_snb

create query bi_16(vertex<person> pid, string countryName, string tagClassName,
                   int minPathDistance, int maxPathDistance) for graph ldbc_snb
{
  // user-defined tuple(s)
  typedef tuple<int personId, string tagName, int messageCount> res;

  // global accumulator(s)
  GroupByAccum<int personId, string tagName, SetAccum<vertex> msgSet> @@groups;
  HeapAccum<res>(100, messageCount desc, tagName asc, personId asc) @@results;

  // vertex-attached accumulator(s)
  SetAccum<vertex<person>> @authorId;

  PersonSeed =  { pid };
  // find all transitive friends of the given person
  FriendSet =
    select tgt
    from src -((person_knows_person>|person_knows_person)*minPathDistance..maxPathDistance)- person:tgt
    ;

  // filter FriendSet by country constraint
  FriendSet =
    select src
    from FriendSet:src -(person_isLocatedIn_city>.city_isPartOf_country>)- country:tgt
    where tgt.name == countryName
    ;

  // find all messages created by person in FriendSet
  MessageSet =
    select tgt
    from FriendSet:src -((<post_hasCreator_person|comments_hasCreator_person))- (post|comments):tgt
    accum tgt.@authorId += src.id
    ;

  // filter MessageSet by tagclass constraint
  MessageSet =
    select src
    from MessageSet:src -((post_hasTag_tag>|comments_hasTag_tag>))- _ -(tag_hasType_tagclass>)- tagclass:tgt
    where tgt.name == tagClassName
    ;

  // aggregate info to @@groups and then to @@results
  MessageSet =
    select src
    from MessageSet:src -((post_hasTag_tag>|comments_hasTag_tag>))- tag:tgt
    accum
      foreach p in src.@authorId do
        @@groups += (p, tgt.name -> src)
      end
    post-accum
      foreach g in @@groups do
        @@results += res(g.personId, g.tagName, g.msgSet.size())
      end
    ;

  print @@results;
}

