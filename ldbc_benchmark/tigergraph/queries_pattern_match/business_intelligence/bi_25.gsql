use graph ldbc_snb

create query bi_25(vertex<person> s, vertex<person> t, datetime startDate,
                   datetime endDate) for graph ldbc_snb
{
  // user-defined tuples
  typedef tuple<string personIds, double weight> path_info;

  // global accumulator(s)
  HeapAccum<path_info>(1, weight desc, personIds asc) @@PathHeap;
  ListAccum<ListAccum<vertex<person>>> @@results;
  SetAccum<vertex<person>> @@explored;
  SetAccum<vertex<person>> @@person_pair; // used for calculating path weight
  SetAccum<vertex> @@messages;
  SumAccum<double> @@weight;
  OrAccum @@stop;

  // vertex-attached accumulator(s)
  ListAccum<ListAccum<vertex<person>>> @pathS;
  ListAccum<ListAccum<vertex<person>>> @pathT;
  OrAccum @seenS;
  OrAccum @seenT;

  // global variables
  int ExploredSize = 0;
  string jsonStr;

  // select all posts in forums created in the given time frame
  ForumSet = { forum.* };
  PostSet =
    select tgt
    from ForumSet:src -(forum_containerOf_post>)- post:tgt
    where src.creationDate >= startDate and src.creationDate <= endDate
    ;

  // initialize s, t vertices
  Start = { s, t };
  Start = select v from Start:v
          accum case when v == s then v.@seenS += true
                     when v == t then v.@seenT += true
                end;
  @@explored += s;
  @@explored += t;

  // loop for graph exploration
  while @@stop == false and @@explored.size() != ExploredSize do
    ExploredSize = @@explored.size();
    Start =
      select v
      from Start:u -((person_knows_person>|<person_knows_person))- person:v
      where ((u.@seenS == true and v.@seenS == false) or // from S frontier
             (u.@seenT == true and v.@seenT == false))   // from T frontier
      accum case
        when ((u.@seenS == true and v.@seenT == true) or
              (u.@seenT == true and v.@seenS == true)) then // u->v joins S, T
          @@stop += true,
          case when (u.@seenS == true and v.@seenT == true) then
            // generate all combo of path from S and path from T
            foreach pathS in u.@pathS do
              foreach pathT in v.@pathT do
                @@results += pathS + [u, v] + pathT
              end
            end // end outer foreach
          end
        when u.@seenS == true then // expand S frontier
          v.@seenS += true, @@explored += v,
          // append u to paths in u.@pathS and append the paths to v.@pathS
          foreach uPath in u.@pathS do
            v.@pathS += uPath + [u]
          end
        when u.@seenT == true then // expand T frontier
          v.@seenT += true, @@explored += v,
          // push u to front of paths in u.@pathT and append paths to v.@pathT
          foreach uPath in u.@pathT do
            v.@pathT += [u] + uPath
          end
        end
      post-accum case
        when v.@seenS == true and v.@seenT == true and @@stop == false then
          @@stop += true,
          // generate all combo of path from S and path from T
          foreach pathS in v.@pathS do
            foreach pathT in v.@pathT do
              @@results += pathS + [v] + pathT
            end
          end // end outer foreach
        end
      ;
  end;

  if @@stop == false then // no path found
    @@results.clear();
  end;

  // aggregate weight values
  @@PathHeap.resize(@@results.size());
  foreach path in @@results do
    jsonStr = "[";
    @@weight = 0.0;
    foreach i in range[0, path.size()-2] do
      @@person_pair.clear();
      @@person_pair += path.get(i);
      @@person_pair += path.get(i+1);
      PersonSeed = { @@person_pair };
      // aggregate the mssages created by the other person in @@messages
      AggregateSet =
        select src
        from PersonSeed:src -(<comments_hasCreator_person)- _
             -((comments_replyOf_comments>|comments_replyOf_post>))- _:msg
             -((comments_hasCreator_person>|comments_hasCreator_person>))- person:tgt
        where src != tgt and tgt in PersonSeed
        accum @@messages += msg
        ;
      // aggregate @@weight for each message that satisties the constraints
      MessageSet = {@@messages};
      MessageSet =
        select src
        from MessageSet:src -((comments_replyOf_comments>|comments_replyOf_post>)*)- post:tgt
        where tgt in PostSet
        accum case
          when src.type == "post" then @@weight += 1.0
          when src.type == "comments" then @@weight += 0.5
          end
        ;
      // create json string representation of the path
      jsonStr += to_string(path.get(i).id) + ",";
    end;
    jsonStr += to_string(path.get(path.size()-1).id) + "]";
    @@PathHeap += path_info(jsonStr, @@weight);
  end;

  print @@PathHeap;
}

