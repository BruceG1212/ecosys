use graph ldbc_snb

create query bi_13(string countryName) for graph ldbc_snb {
  // user-defined tuples
  typedef tuple<string name, int popularity> TagPair;
  typedef tuple<int year, int month, string popularTags> ResultTuple;

  // global accumulator
  HeapAccum<TagPair>(5, popularity desc, name asc) @@tag_selector;
  HeapAccum<ResultTuple>(100, year desc, month asc) @@result;
  GroupByAccum<int year, int month, MapAccum<vertex<tag>, int> tagMap> @@groups;

  // vertex-attached accumulator
  SumAccum<int> @creationYear;
  SumAccum<int> @creationMonth;
  SumAccum<int> @popularity;

  // global variable declaration
  string jsonStr;
  bool first;

  // seed set
  CountrySeed = { country.* };

  // select messages from the given country and calculate its year and month
  MessageSet =
    select tgt
    from CountrySeed:src -((<post_isLocatedIn_country|<comments_isLocatedIn_country))- _:tgt
    where src.name == countryName
    accum tgt.@creationYear += year(tgt.creationDate),
          tgt.@creationMonth += month(tgt.creationDate)
    ;

  // aggregate popularity for each tag referenced by messages in MessageSet
  AggregateMessageSet =
    select src
    from MessageSet:src -((post_hasTag_tag>|comments_hasTag_tag>))- tag:tgt
    accum @@groups += (src.@creationYear, src.@creationMonth -> (tgt -> 1))
    ;

  foreach g in @@groups do
    // select the top 5 popular tags for each group
    foreach (vTag, popularity) in g.tagMap do
      @@tag_selector += TagPair(vTag, popularity);
    end;
    // create result entry for each group
    jsonStr = "[";
    first = true;
    while @@tag_selector.size() != 0 do
      if first == false then
        jsonStr += ",";
      else
        first = false;
      end;
      // consruct json string representation of TagPair tuple
      jsonStr += "[\"" + @@tag_selector.top().name + "\",";
      jsonStr += to_string(@@tag_selector.top().popularity) + "]";
      @@tag_selector.pop();
    end;
    @@result += ResultTuple(g.year, g.month, jsonStr);
  end;

  print @@result;
}

