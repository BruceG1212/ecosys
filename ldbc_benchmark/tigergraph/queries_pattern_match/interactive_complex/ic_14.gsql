use graph ldbc_snb

create query ic_14(vertex<person> s, vertex<person> t) for graph ldbc_snb {
  // user-defined tuples
  typedef tuple<string personIdsInPath, double weight> path_info;

  // global accumulators
  HeapAccum<path_info>(1, weight desc) @@PathHeap;
  ListAccum<ListAccum<vertex<person>>> @@results;
  SetAccum<vertex<person>> @@person_pair; // for calculating path weight
  SetAccum<vertex<person>> @@explored;
  SumAccum<double> @@weight;
  OrAccum @@stop;

  // vertex-attached accumulators
  ListAccum<ListAccum<vertex<person>>> @pathS;
  ListAccum<ListAccum<vertex<person>>> @pathT;
  OrAccum @seenS;
  OrAccum @seenT;

  // global variables
  int ExploredSize = 0;
  string jsonStr;

  // check for zero-length condition
  if s == t then
    @@results += [s, t];
    @@stop += true;
  end;

  // initialize s, t vertices
  Start = { s, t };
  Start = select v from Start:v
          accum case when v == s then v.@seenS += true
                     when v == t then v.@seenT += true
                end;
  @@explored += s;
  @@explored += t;

  // loop for graph exploration
  while @@stop == false and @@explored.size() != ExploredSize do
    ExploredSize = @@explored.size();
    Start = 
      select v
      from Start:u -((person_knows_person>|<person_knows_person))- person:v
      where ((u.@seenS == true and v.@seenS == false) or // from S frontier
             (u.@seenT == true and v.@seenT == false)) // from T frontier
      accum case
        when ((u.@seenS == true and v.@seenT == true) or
              (u.@seenT == true and v.@seenS == true)) then // u->v joins S,T
          @@stop += true,
          case when (u.@seenS == true and v.@seenT == true) then
            // generate all combo of path from S and path from T
            foreach pathS in u.@pathS do
              foreach pathT in v.@pathT do
                @@results += pathS + [u, v]  + pathT
              end
            end // end outer foreach
          end
        when u.@seenS == true then // expand S frontier
          v.@seenS += true, @@explored += v,
          // append u to paths in u.@pathS and append the paths to v.@pathS
          foreach uPath in u.@pathS do
            v.@pathS += uPath + [u]
          end
        when u.@seenT == true then // expand T frontier
          v.@seenT += true, @@explored += v,
          // push u to front of paths in u.@pathT and append paths to v.@pathT
          foreach uPath in u.@pathT do
            v.@pathT += [u] + uPath
          end
        end
      post-accum case
        when v.@seenS == true and v.@seenT == true and @@stop == false then
          @@stop += true,
          // geberate all combo of path from S and path from T
          foreach pathS in v.@pathS do
            foreach pathT in v.@pathT do
              @@results += pathS + [v] + pathT
            end
          end // end outer foreach
        end
      ;
  end;

  if @@stop == false then
    @@results.clear();
  end;

  // order the shortest path by weight
  @@PathHeap.resize(@@results.size());
  foreach path in @@results do
    jsonStr = "[";
    @@weight = 0.0;
    foreach i in range[0, path.size()-2] do
      @@person_pair.clear();
      @@person_pair += path.get(i);
      @@person_pair += path.get(i+1);
      // aggregate path weight for every consecutive pair on the path
      PersonSeed = { @@person_pair };
      AggregateSet =
        select src
        from PersonSeed:src -(<comments_hasCreator_person)- _
             -((comments_replyOf_comments>|comments_replyOf_post>))- _:msg
             -((comments_hasCreator_person>|post_hasCreator_person>))- person:tgt
        where src != tgt and tgt in PersonSeed
        accum case
          when msg.type == "post" then @@weight += 1.0
          when msg.type == "comments" then @@weight += 0.5
          end
        ;
      jsonStr += to_string(path.get(i).id) + ",";
    end;
    jsonStr += to_string(path.get(path.size()-1).id) + "]";
    @@PathHeap += path_info(jsonStr, @@weight);
  end;

  print @@PathHeap;
}

