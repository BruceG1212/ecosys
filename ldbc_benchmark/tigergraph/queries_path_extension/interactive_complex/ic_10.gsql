USE GRAPH ldbc_snb
DROP QUERY ic_10

CREATE QUERY ic_10(vertex<Person> personId, int month, int nextMonth) FOR GRAPH ldbc_snb {
  TYPEDEF tuple<int personId, 
                string personFirstName, 
                string personLastName, 
                int commonInterestScore, 
                string personGender, 
                string personCityName> friendInfo;

  OrAccum @visited;

  SumAccum<string> @city;
  SetAccum<vertex<Person>> @@friendAll;
  SetAccum<int> @@interestedTagIds;
  SumAccum<int> @common, @uncommon;
  HeapAccum<friendInfo>(10, commonInterestScore DESC, personId ASC) @@friendInfoTop;

  vPerson = { personId };
	
  vPerson = 
    SELECT s
    FROM vPerson:s-(Person_KNOWS_Person>*2..2:e1)-Person:im-(Person_IS_LOCATED_IN_City>)-City:t
    WHERE im.@visited == False
    AND ((month(im.birthday) == month AND day(im.birthday) >= 21) OR 
         (month(im.birthday) == nextMonth AND day(im.birthday) < 22))
    ACCUM 
      s.@visited += True,
      im.@visited += True,
      im.@city = t.name,
      @@friendAll += im;

  vFriend = { @@friendAll };

  vTag = 
    SELECT t
    FROM vPerson:s-(Person_HAS_INTEREST_Tag>:e)-Tag:t
    POST-ACCUM @@tagInterest += t;
	
  vFriend = 
    SELECT s
    FROM vFriend:s-(<Post_HAS_CREATOR_Person:e1.Post_HAS_TAG_Tag>:e2)-Tag:t
    ACCUM
      CASE WHEN @@interestedTagIds.contains(t.id) == True THEN 
        s.@common += 1
      ELSE 
        s.@uncommon += 1
      END
    POST-ACCUM @@friendInfoTop += friendInfo(s.id, s.firstName, s.lastName, (s.@common-s.@uncommon), s.gender, s.@city);

  PRINT @@friendInfoTop;
}

INSTALL QUERY ic_10