CREATE QUERY cc_rank_by_gini(int k=100, int cutoff=30) FOR GRAPH MyGraph {

  TYPEDEF TUPLE<vertex ancestor,int depth, int size, double gini> cc_stat;

  MaxAccum<vertex> @ancestor;
  SumAccum<int> @invitee_cnt;
  GroupByAccum<vertex cc, MaxAccum<int> depth, SumAccum<int> size> @@cc_depth_size;
  HeapAccum<cc_stat>(k, gini DESC, cc_size DESC, ccc_depth DESC) @@top_k_cc;
  MapAccum<vertex, BagAccum<int>> @@cc_invitee_count_bag;

  int depth = 0;
  int sum_diffs;
  int sum;
  double gini;



  //find all cc's starting account.
  ancestors =
    SELECT t
    FROM Account:t
    WHERE t.outdegree("invite") > 0 AND t.outdegree("reverse_invite") == 0
    ACCUM t.@ancestor = t
    POST-ACCUM 
          @@cc_depth_size += (t.@ancestor->0, 1);


  //propagate each cc's starting account to all its cc children.
  //for each child, we store the path from starting point to that child. 
  //in this graph, there is no two person invite the same account scenarios.
  children = ancestors;

  WHILE (children.size() > 0) DO
    depth = depth +1;
    children =
      SELECT t
      FROM children:s - (invite>:e) - Account:t
      ACCUM t.@ancestor = s.@ancestor, 
            s.@invitee_cnt += 1
      POST-ACCUM 
              //update cc depth and size
              @@cc_depth_size += (t.@ancestor->depth, 1);
  END;

  //below shows how we use accumulator to record state and summarize them.
  //for each cc, get the bag of invitee_cnt.
  tt = SELECT t
       FROM Account:t
       ACCUM @@cc_invitee_count_bag += (t.@ancestor -> t.@invitee_cnt);
      

    //loop each cc and its bag of invitee count
  FOREACH (cc, bag) IN @@cc_invitee_count_bag DO 
    sum_diffs = 0;
    sum = 0;
    gini = 0;

    //nested loop of bag count
    FOREACH x1 IN bag DO 
      sum = sum + x1;
      FOREACH x2 IN bag DO 
        sum_diffs = sum_diffs + abs(x1-x2);
      END;
    END;

    gini = 0.5 * sum_diffs / (bag.size()*sum);

    //push to top_k_cc heap
    IF bag.size() >= cutoff THEN
      @@top_k_cc += cc_stat(cc, @@cc_depth_size.get(cc).depth, @@cc_depth_size.get(cc).size, gini);
    END;

  END;

  //output the heap entry
  FOREACH c IN @@top_k_cc DO
    PRINT c.ancestor AS ancestor, c.depth AS depth, c.size AS size, c.gini AS gini_index;
  END;
}
