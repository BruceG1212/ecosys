//we only count those populations that have corresponding imei. For those which does not have
//account, we ignore them as they dont have enough info for us. 
#using group by, foreach to find top-k. 
use graph MyGraph

CREATE QUERY cc_rank_by_account_per_imei(int cutoff, int k) FOR GRAPH MyGraph Syntax V2 {

  TYPEDEF TUPLE<vertex ancestor, float share_device_rate, int tot_accounts> cc_stats;
  MaxAccum<vertex> @ancestor;
  GroupByAccum<vertex ancestor, vertex imei, SumAccum<int> cnt> @@groupby_cc_imei;
  GroupByAccum<vertex ancestor, AvgAccum share_device_rate, SumAccum<int> tot> @@cc_share_device_rate;
  HeapAccum<cc_stats>(k, share_device_rate DESC, tot_accounts DESC) @@top_k_cc;

 //find all cc's starting account.
  ancestors =
    SELECT acct
    FROM Account:acct
    WHERE acct.outdegree("invite") > 0 AND acct.outdegree("reverse_invite") == 0
    ACCUM acct.@ancestor = acct;


  children = ancestors;
  WHILE (children.size() > 0) DO
    r =
      SELECT tgt
      FROM children:src -(use_imei:e)- IMEI:tgt
      //for each (cc, imei)-->account. 
      //normal cc, has #imei== #account
      ACCUM @@groupby_cc_imei += (src.@ancestor, tgt -> 1);

    children =
      SELECT t
      FROM children:s - (invite>:e) - Account:t
      ACCUM t.@ancestor = s.@ancestor;
  END;

  FOREACH (cc, imei, cnt) IN @@groupby_cc_imei DO
    //each cc, what's imei avg account number. 
    //for those who do not have imei, we don't include them in the stats result. 
    @@cc_share_device_rate += (cc -> cnt, cnt);
  END;

  //loop an container entry, do sort using HeapAccum
  FOREACH (cc, avg_rate, tot) IN @@cc_share_device_rate DO
    IF tot >= cutoff THEN
      @@top_k_cc += cc_stats(cc, avg_rate, tot);
    END;
  END;

  //output the heap entry
  FOREACH c IN @@top_k_cc DO
    PRINT c.ancestor AS ancestor, c.share_device_rate AS share_device_rate, c.tot_accounts AS num_accounts;
  END;
}
